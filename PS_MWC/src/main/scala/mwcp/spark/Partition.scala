package mwcp.spark

import mwcp.spark.MWCP.{MWCL, Subproblem}
import mwcp.spark.FastWclqZK._
import org.apache.spark.SparkContext
import org.apache.spark.broadcast.Broadcast
import org.apache.spark.graphx.{EdgeDirection, Graph, VertexId, VertexRDD}
import org.apache.spark.rdd.RDD

import scala.collection.Map
import scala.collection.mutable.Buffer

/**
  * Created by qiuqian on 3/28/18.
  */
object Partition  extends LogHelper{

  def partition(weightedGraph: Graph[Double, Int], quickMwclWeight: Double, onlyByVid: Boolean = false) : VertexRDD[(Double, Set[VertexId])]= {

    val startTime = System.currentTimeMillis()

    weightedGraph.cache()

    val degreeGraph = weightedGraph.outerJoinVertices(weightedGraph.degrees)((vid, weight, degOpt) => (weight, degOpt.getOrElse(0)))

    degreeGraph.cache()

    logInfo("generated degreeGraph")

    //take vertices by degree in asc ordering
    //nbVertices the property contains (SetOfHigherOrderingNeighbors, SumOfHigherOrderingNeighborsWeight, weightOfThisVertex)
    /*
    This version costs 176s while our adopted strategy costs 88s on test data.
    This version keeps weight in hnbVertices, so doesn't have to leftJoin vertices to get their weight;
    However, this strategy is more costly than leftJoin vertices.

    val hnbVertices: VertexRDD[(Set[VertexId], Double, Double)] = {
      onlyByVid match {
        case true => degreeGraph.aggregateMessages[(Set[VertexId], Double, Double)] (
          triplet => {
            // for each pair of neighbors, send higher id and weight to lower id vertex
            if (triplet.srcId > triplet.dstId) triplet.sendToDst((Set(triplet.srcId), triplet.srcAttr._1, triplet.dstAttr._1))
            else triplet.sendToSrc((Set(triplet.dstId), triplet.dstAttr._1, triplet.srcAttr._1))
          },
          //merge neighbors and add up the weights
          (n1, n2) => (n1._1 ++ n2._1, n1._2 + n2._2, n1._3)
        )
        case false => degreeGraph.aggregateMessages[(Set[VertexId], Double, Double)] (
          triplet => {
            //srcAttr and dstAttr: (weight, degree)
            if(triplet.srcAttr._2 > triplet.dstAttr._2) {
              //if src has higher degree, send src's id and weight to dest
              triplet.sendToDst((Set(triplet.srcId), triplet.srcAttr._1, triplet.dstAttr._1))
            }else if(triplet.srcAttr._2 == triplet.dstAttr._2){
              // if src and dst have equal degree, send higher id and weight to lower id vertex
              if(triplet.srcId > triplet.dstId) triplet.sendToDst((Set(triplet.srcId), triplet.srcAttr._1, triplet.dstAttr._1))
              else triplet.sendToSrc((Set(triplet.dstId), triplet.dstAttr._1, triplet.srcAttr._1))
            }else {
              // if desc has higher degree, send desc's id and weight to src
              triplet.sendToSrc((Set(triplet.dstId), triplet.dstAttr._1, triplet.srcAttr._1))
            }
          },
          //merge neighbors and add up the weights, also keep the weight of this vertex
          (n1, n2) => (n1._1 ++ n2._1, n1._2 + n2._2, n1._3)
        )
      }

    }

    logInfo("generated nbVertices")

    var verticesWithHNbRDD: VertexRDD[(Double, Set[VertexId])] =
      hnbVertices.mapValues{set_sumHNb_weight =>
        //if sum of this vertex'weight and its higher-ordering neighbors' weight is not greater than current
        // clique weight, we don't need to process the subgraph which is generated by this vertex
        if (set_sumHNb_weight._2 + set_sumHNb_weight._3 <= quickMwclWeight) (0D, Set[VertexId]())
        else (set_sumHNb_weight._3, set_sumHNb_weight._1)
      }.filter(_._1 != 0)
      */

    val hnbVertices: VertexRDD[(Buffer[VertexId], Double)] = {
      onlyByVid match {
        case true => degreeGraph.aggregateMessages[(Buffer[VertexId], Double)](
          triplet => {
            // for each pair of neighbors, send higher id and weight to lower id vertex
            if (triplet.srcId > triplet.dstId) triplet.sendToDst((Buffer(triplet.srcId), triplet.srcAttr._1))
            else triplet.sendToSrc((Buffer(triplet.dstId), triplet.dstAttr._1))
          },
          //merge neighbors and add up the weights
          (n1, n2) => (n1._1 ++ n2._1, n1._2 + n2._2)
        )
        case false => degreeGraph.aggregateMessages[(Buffer[VertexId], Double)](
          triplet => {
            //srcAttr and dstAttr: (weight, degree)
            if (triplet.srcAttr._2 > triplet.dstAttr._2) {
              //if src has higher degree, send src's id and weight to dest
              triplet.sendToDst((Buffer(triplet.srcId), triplet.srcAttr._1))
            } else if (triplet.srcAttr._2 == triplet.dstAttr._2) {
              // if src and dst have equal degree, send higher id and weight to lower id vertex
              if (triplet.srcId > triplet.dstId) triplet.sendToDst((Buffer(triplet.srcId), triplet.srcAttr._1))
              else triplet.sendToSrc((Buffer(triplet.dstId), triplet.dstAttr._1))
            } else {
              // if desc has higher degree, send desc's id and weight to src
              triplet.sendToSrc((Buffer(triplet.dstId), triplet.dstAttr._1))
            }
          },
          //merge neighbors and add up the weights
          (n1, n2) => (n1._1 ++ n2._1, n1._2 + n2._2)
        )
      }
    }


    /* send lower degree and id to higher vertex;
    cost 402s comparing to 88s sending higher degree and id to lower vertex;

    val hnbVertices: VertexRDD[(Set[VertexId], Double)] = {
      degreeGraph.aggregateMessages[(Set[VertexId], Double)] (
        triplet => {
          //srcAttr and dstAttr: (weight, degree)
          if(triplet.srcAttr._2 < triplet.dstAttr._2) {
            //if src has lower degree, send src's id and weight to dest
            triplet.sendToDst((Set(triplet.srcId), triplet.srcAttr._1))
          }else if(triplet.srcAttr._2 == triplet.dstAttr._2){
            // if src and dst have equal degree, send lower id and weight to higher id vertex
            if(triplet.srcId < triplet.dstId) triplet.sendToDst((Set(triplet.srcId), triplet.srcAttr._1))
            else triplet.sendToSrc((Set(triplet.dstId), triplet.dstAttr._1))
          }else {
            // if desc has lower degree, send desc's id and weight to src
            triplet.sendToSrc((Set(triplet.dstId), triplet.dstAttr._1))
          }
        },
        //merge neighbors and add up the weights
        (n1, n2) => (n1._1 ++ n2._1, n1._2 + n2._2)
      )
    }
    */
    hnbVertices.cache()

    logInfo("generated nbVertices")

    var verticesWithHNbRDD: VertexRDD[(Double, Set[VertexId])] =
      hnbVertices.leftJoin(weightedGraph.vertices)((vid, setAndSumHNb, weight) => weight match {
        case Some(weight) =>
          //if sum of this vertex'weight and its higher-ordering neighbors' weight is not greater than current
          // clique weight, we don't need to process the subgraph which is generated by this vertex
          if(weight + setAndSumHNb._2 <= quickMwclWeight) (0D, Set[VertexId]())
          else (weight.toDouble, setAndSumHNb._1.toSet)
        case None => (0D, Set[VertexId]())
      }).filter(_._2._1 != 0)

    logInfo("generated verticesWithNbRDD")

    logInfo("Number of partitions of verticesWithNbRDD: " + verticesWithHNbRDD.partitions.length)

    var timeCost = (System.currentTimeMillis() - startTime) / 1000
    logInfo("Time Cost: " + timeCost + " seconds")

    verticesWithHNbRDD

  }

}

