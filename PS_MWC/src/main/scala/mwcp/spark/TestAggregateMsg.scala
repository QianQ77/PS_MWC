package mwcp.spark

import java.io.File

import mwcp.spark.MWCP.Subproblem
import org.apache.spark.broadcast.Broadcast
import org.apache.spark.graphx.{EdgeDirection, VertexId}
import org.apache.spark.{SparkConf, SparkContext}
import org.apache.zookeeper.{WatchedEvent, Watcher, ZooKeeper}

import scala.collection.Map
import scala.collection.mutable.Buffer
import scala.tools.nsc.classpath.FileUtils

/**
  * Created by qiuqian on 4/28/18.
  */
object TestAggregateMsg extends Watcher{

  var optimumWeight: Double = 200

  var zk: ZooKeeper = null

  def main(args: Array[String]): Unit = {
    val conf = new SparkConf().setAppName("MWCP_SPARK").setMaster("local[4]")

    val sc = new SparkContext(conf)

    val inputPath = "data/web-uk-2005.mtx"

    val edgeParNum = 8

    val zooKeeperServerIp = "localhost"

    if(zk == null) {
      zk = ZKHelper.startZK(this, zooKeeperServerIp)
      ZKHelper.initializeZNode(zk, optimumWeight)
    }

    var weightedGraph = MWCP.generateGraphFromInput(sc, inputPath, edgeParNum)
    weightedGraph.cache()

    var weightMap_bc: Broadcast[Map[VertexId, Double]] = sc.broadcast(weightedGraph.vertices.collectAsMap())

    var neighborsMap_bc: Broadcast[Map[VertexId, Array[VertexId]]] =
      sc.broadcast(weightedGraph.collectNeighborIds(EdgeDirection.Either).collectAsMap())

    var ubDegreeGraph = ReduceGraph.getUBDegreeGraph(weightedGraph)

    ubDegreeGraph.cache()

    //cost 21.2s, 19s, 16s, 17s
    val hnbVertices = ubDegreeGraph.aggregateMessages[(Buffer[VertexId], Double, Double)](
      triplet => {
        //srcAttr and dstAttr: (weight, upperbound, degree)
        //send message only if the upperbounds of src and desc are both larger than optimumWeight
        if(triplet.srcAttr._2 > optimumWeight && triplet.dstAttr._2 > optimumWeight) {
          if (triplet.srcAttr._3 > triplet.dstAttr._3) {
            //if src has higher degree, send src's id and weight to dest
            triplet.sendToDst((Buffer(triplet.srcId), triplet.srcAttr._1, triplet.dstAttr._1))
          } else if (triplet.srcAttr._3 == triplet.dstAttr._3) {
            // if src and dst have equal degree, send higher id and weight to lower id vertex
            if (triplet.srcId > triplet.dstId) triplet.sendToDst((Buffer(triplet.srcId), triplet.srcAttr._1 , triplet.dstAttr._1))
            else triplet.sendToSrc((Buffer(triplet.dstId), triplet.dstAttr._1, triplet.srcAttr._1))
          } else {
            // if desc has higher degree, send desc's id and weight to src
            triplet.sendToSrc((Buffer(triplet.dstId), triplet.dstAttr._1, triplet.srcAttr._1))
          }
        }

      },
      //merge neighbors and add up the weights
      (n1, n2) => (n1._1 ++ n2._1, n1._2 + n2._2, n1._3)
    ).filter(vertex => vertex._2._2 + vertex._2._3 > optimumWeight) //if sum of this vertex'weight and its higher-ordering neighbors' weight is not greater than current
    // clique weight, we don't need to process the subgraph which is generated by this vertex

    //cost 20.8s, 19s, 18s
    //The output RDD's attribute: (upperBoundHNb, set of Higher order neighbors' id)
    //upperBoundHNb = sum of weights of Higher oder neighbors + this vertex's neighbor
    val hnbVertices2 = ubDegreeGraph.aggregateMessages[(Buffer[VertexId], Double)](
      triplet => {
        //srcAttr and dstAttr: (weight, upperbound, degree)
        //send message only if the upperbounds of src and desc are both larger than optimumWeight
        if(triplet.srcAttr._2 > optimumWeight && triplet.dstAttr._2 > optimumWeight) {
          if (triplet.srcAttr._3 > triplet.dstAttr._3) {
            //if src has higher degree, send src's id and weight to dest
            triplet.sendToDst((Buffer(triplet.srcId), triplet.srcAttr._1))
          } else if (triplet.srcAttr._3 == triplet.dstAttr._3) {
            // if src and dst have equal degree, send higher id and weight to lower id vertex
            if (triplet.srcId > triplet.dstId) triplet.sendToDst((Buffer(triplet.srcId), triplet.srcAttr._1))
            else triplet.sendToSrc((Buffer(triplet.dstId), triplet.dstAttr._1))
          } else {
            // if desc has higher degree, send desc's id and weight to src
            triplet.sendToSrc((Buffer(triplet.dstId), triplet.dstAttr._1))
          }
        }

      },
      //merge neighbors and add up the weights
      (n1, n2) => (n1._1 ++ n2._1, n1._2 + n2._2)
    ).leftJoin(weightedGraph.vertices)((vid, setAndSumHNb, weight) =>
      (weight.getOrElse(0D) + setAndSumHNb._2, setAndSumHNb._1.toSet)).filter(vertex => vertex._2._1 > optimumWeight) //if sum of this vertex'weight and its higher-ordering neighbors' weight is not greater than current
    // clique weight, we don't need to process the subgraph which is generated by this vertex

    val startTime = System.currentTimeMillis()
    /*
    val result = hnbVertices2.map{
      case (vid, (weight, hnbSet)) =>
        Subproblem(Some(List(vid)), hnbSet)
    }.map(_subproblem => FastWclqZK.fastWClq_ZK(zooKeeperServerIp, _subproblem, weightMap_bc, neighborsMap_bc)).
      filter(_ != None).coalesce(1).reduce(MWCP.maxMWCL(_ , _))
    println("Result: " + result.get.weight + " vertices: " +result.get.vertices )
    */

    hnbVertices2.saveAsTextFile("data/hnbVertices")

    println("Time Cost: " + (System.currentTimeMillis() - startTime))

  }

  override def process(watchedEvent: WatchedEvent) = {
    //optimumWeight = ZKHelper.readWeightFromZookeeper(zk, this)
  }

}
